package templates

import "github.com/Joao-Felisberto/devprivops-dashboard/data"
// import "github.com/Joao-Felisberto/devprivops-dashboard/util"
// import "fmt"
// import "strconv"
// import "time"
// import "sort"
// import "slices"

templ RequirementsPage(userStories ...*data.UserStory) {
    <h1 class="heading text-3xl">
       User Story Completion
    </h1>

    for _, us := range userStories {
        @US(us)
    }
}

templ US(us *data.UserStory) {
    <h2 class="heading text-2xl">
       Completion of {us.UseCase}
    </h2>

    for _, req := range us.Requirements {
        @Requirement(&req)
    }
}

templ Requirement(requirement *data.Requirement) {
    <div class="card">
        <h3 class="text-xl text-emerald-500">
            {requirement.Title}
        </h3>
        <p class="py-5">
            {requirement.Description}
        </p>
        
        @RequirementTable(&requirement.Results)
    </div>
}

// TODO unify with the other, isolate all that into a utils file or whatever
templ RequirementTable(requirementInfo *[]map[string]interface{}) {
    <table>
        <thead> 
        <tr>
        for _, k := range getVars(requirementInfo) {
            <th>{k}</th>
        }
        </tr>
        </thead>
        <tbody>
        for _, ln := range toTable(requirementInfo) {
            <tr>
            for _, e := range ln {
                <td>{e}</td>
            }
            </tr>
        }
        </tbody>
    </table>
}

/*
func getVars(requirementInfo *[]map[string]interface{}) []string {
    if len(*requirementInfo) == 0 {
        return []string {}
    }
    first := (*requirementInfo)[0]

    keys := []string {}
    for k, _ := range first {
        keys = append(keys, display(k))
    }

    slices.Sort(keys)
    return keys
}

func toTable(violations *[]map[string]interface{}) [][]string {
    if len(*violations) == 0 {
        return [][]string {}
    }
    first := (*violations)[0]

    keys := []string {}
    res := [][]string {}
    for k, _ := range first {
        keys = append(keys, display(k))
    }
    slices.Sort(keys)

    for _, violation := range *violations {
        line := []string {}
        for _, k := range keys {
            line = append(line, display(violation[k]))
        }
        res = append(res, line)
    }

    return res
}

func display(v interface{}) string {
    switch t := v.(type) {
        case string:
            return t
        case int:
            return strconv.Itoa(t)
        case float64:
            return strconv.FormatFloat(t, 'f', -1, 64)
        default:
            return fmt.Sprintf("%v", v)
    }
}
*/